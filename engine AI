repeat task.wait() until game:IsLoaded()

if game.PlaceId ~= 139394516128799 then return end

local req = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
local HttpService = game:GetService("HttpService")

function DisconnectAll(connections)
	task.spawn(function()
		for i, connection in pairs(connections) do
			if connection then
				connection:Disconnect()
				connections[i] = nil
			end
		end
	end)
end

if getgenv().Info and getgenv().Info.Connections then
	DisconnectAll(getgenv().Info.Connections)
end

-- ข้อมูล AI ที่เสถียรที่สุดของเรา
getgenv().Info = {
	EngineOptions = { "Lichess", "Stockfish 17", "Leela Chess Zero", "Next Chess Move", "Shredder", "Sunfish" },
	EnginePriority = { "Lichess", "Leela Chess Zero", "Next Chess Move", "Stockfish 17", "Shredder", "Sunfish" },
	Connections = {},
}

getgenv().Settings = {
	AutoPlay = false,
	Engine = "Lichess",
}

-- Rayfield UI ที่พิสูจน์แล้วว่าทำงานได้ 100%
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
	Name = "Chess Universe v5.0",
	Icon = 0,
	LoadingTitle = "Chess Universe - The Final Chapter",
	LoadingSubtitle = "by Shrx & Us",
	Theme = "Default",
	ToggleUIKeybind = "K",
	ConfigurationSaving = { Enabled = true, FileName = "ChessUniverseFinal" },
})


-- ==========================================================
--                  ENGINE API FUNCTIONS (Clean Code)
-- ==========================================================

function BestMove_Lichess(FEN)
	local res
	local success, err = pcall(function()
		res = req({ Url = "https://lichess.org/api/cloud-eval?fen=" .. HttpService:UrlEncode(FEN), Method = "GET" })
	end)
	
	if success and res and res.Success then
		local data = HttpService:JSONDecode(res.Body)
		if data and not data.error and data.pvs and #data.pvs > 0 and data.pvs[1].moves then
			local uci = data.pvs[1].moves:split(" ")[1]
			if uci and #uci >= 4 then
				return uci:sub(1, 2), uci:sub(3, 4)
			end
		else
			warn("[Engine] Lichess API error:", data.error or "No move found")
		end
	else
		warn("[Engine] Lichess request failed:", err or res.StatusCode)
	end
	return nil
end

function BestMove_Stockfish17(FEN)
	local res
	local success, err = pcall(function()
		res = req({ Url = "https://chess-api.com/v1", Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = HttpService:JSONEncode({ fen = FEN }) })
	end)
	
	if success and res and res.Success then
		local data = HttpService:JSONDecode(res.Body)
		return data.from, data.to
	else
		warn("[Engine] Stockfish request failed:", err or res.StatusCode)
	end
	return nil
end

function BestMove_NCM(FEN)
    local res
    local success, err = pcall(function()
        res = req({ Url = "https://www.nextchessmove.com/api/v4/calculate?fen=" .. HttpService:UrlEncode(FEN), Method = "GET" })
    end)
	
    if success and res and res.Success then
        local data = HttpService:JSONDecode(res.Body)
        if data and data.best_move and data.best_move.uci then
            local uci = data.best_move.uci
            return uci:sub(1, 2), uci:sub(3, 4)
        else
            warn("[Engine] NCM API returned invalid data.")
        end
    else
        warn("[Engine] NCM request failed:", err or res.StatusCode)
    end
    return nil
end

function BestMove_Shredder(FEN)
    local res
    local success, err = pcall(function()
        res = req({ Url = "https://lichess.org/api/cloud-eval?fen=" .. HttpService:UrlEncode(FEN) .. "&multiPv=1&variant=standard&engine=shredder", Method = "GET" })
    end)
	
    if success and res and res.Success then
        local data = HttpService:JSONDecode(res.Body)
        if data and not data.error and data.pvs and #data.pvs > 0 and data.pvs[1].moves then
            local uci = data.pvs[1].moves:split(" ")[1]
            if uci and #uci >= 4 then
                print("[Engine] Shredder suggests move: " .. uci)
                return uci:sub(1, 2), uci:sub(3, 4)
            end
        else
            warn("[Engine] Shredder analysis not found.")
        end
    else
        warn("[Engine] Shredder (Lichess) request failed:", err or res.StatusCode)
    end
    return nil
end

function BestMove_LCZero(FEN)
    local res
    local success, err = pcall(function()
        res = req({ Url = "https://lichess.org/api/cloud-eval?fen=" .. HttpService:UrlEncode(FEN) .. "&multiPv=1&variant=standard&engine=lc0", Method = "GET" })
    end)
	
    if success and res and res.Success then
        local data = HttpService:JSONDecode(res.Body)
        if data and not data.error and data.pvs and #data.pvs > 0 and data.pvs[1].moves then
            local uci = data.pvs[1].moves:split(" ")[1]
            if uci and #uci >= 4 then
                print("[Engine] LCZero suggests move: " .. uci)
                return uci:sub(1, 2), uci:sub(3, 4)
            end
        else
            warn("[Engine] LCZero analysis not found.")
        end
    else
        warn("[Engine] LCZero (Lichess) request failed:", err or res.StatusCode)
    end
    return nil
end

function BestMove_Sunfish(FEN)
	local ok, result = pcall(function()
		return require(game:GetService("Players").LocalPlayer.PlayerScripts.AI.Sunfish):GetBestMove(FEN, 2000)
	end)
	
	if ok and result then
		return result
	else
		warn("[Engine] Sunfish engine failed:", result)
	end
	return nil
end

-- ==========================================================
--                  CORE SYSTEM
-- ==========================================================
function BestMove(engine)
	local FEN = game:GetService("ReplicatedStorage").InternalClientEvents.GetActiveTableset:Invoke():WaitForChild("FEN").Value
	
	if engine == "Lichess" then return BestMove_Lichess(FEN)
	elseif engine == "Stockfish 17" then return BestMove_Stockfish17(FEN)
	elseif engine == "Next Chess Move" then return BestMove_NCM(FEN)
	elseif engine == "Shredder" then return BestMove_Shredder(FEN)
	elseif engine == "Leela Chess Zero" then return BestMove_LCZero(FEN)
	elseif engine == "Sunfish" then
		local from, to = BestMove_Sunfish(FEN)
		if to then return from, to end
		return from
	end
	return nil
end

function PlayMove(engine)
	local from, to = BestMove(engine)
	task.wait()
	
	if from and to then
		game:GetService("ReplicatedStorage").Chess.SubmitMove:InvokeServer(from .. to)
		return true
	elseif from then
		game:GetService("ReplicatedStorage").Chess.SubmitMove:InvokeServer(from)
		return true
	else
		warn("[Move] Invalid move received from engine '" .. engine .. "'. Cannot play.")
		return false
	end
end

function PlayWithFallback()
	task.spawn(function()
		local movePlayed, selectedEngine, enginesToTry = false, getgenv().Settings.Engine, {}
		table.insert(enginesToTry, selectedEngine)
		for _, engineName in ipairs(getgenv().Info.EnginePriority) do
			if engineName ~= selectedEngine then table.insert(enginesToTry, engineName) end
		end
		
		for i, engineName in ipairs(enginesToTry) do
			print("[System] Attempting to get move from:", engineName)
			movePlayed = PlayMove(engineName)
			if movePlayed then
				if i > 1 then
					Rayfield:Notify({ Title = "Engine Fallback", Content = "Using '"..engineName.."' for this move.", Duration = 6, Image = "rbxassetid://4324241349" })
				end
				break
			end
		end
		if not movePlayed then
			warn("[FATAL] All engines failed to provide a valid move.")
			Rayfield:Notify({ Title = "Error!", Content = "All engines failed to respond.", Duration = 8, Image = "rbxassetid://4324241353" })
		end
	end)
end

function AutoPlay()
	if not getgenv().Settings.AutoPlay then return end
	
	DisconnectAll(getgenv().Info.Connections)
	getgenv().Info.Connections["MoveRecieved"] = game:GetService("ReplicatedStorage").Chess.MovePlayedRemoteEvent.OnClientEvent:Connect(PlayWithFallback)
	getgenv().Info.Connections["GameStart"] = game:GetService("ReplicatedStorage").Chess:WaitForChild("StartGameEvent").OnClientEvent:Connect(PlayWithFallback)
	PlayWithFallback()
end

-- ==========================================================
--                  USER INTERFACE (RAYFIELD - Perfected)
-- ==========================================================
local MainTab = Window:CreateTab("Main", "code-xml")
MainTab:CreateSection("Select Engine API")
MainTab:CreateDropdown({
	Name = "Engine API",
	Options = getgenv().Info.EngineOptions,
	CurrentOption = getgenv().Settings.Engine,
	MultipleOptions = false,
	Callback = function(Options)
		-- [THE FIX!] กลับมาใช้การเชื่อมต่อที่ถูกต้องเหมือนในโค้ดเก่าที่ทำงานได้!
		getgenv().Settings.Engine = Options[1]
		print("Selected Engine:", Options[1])
	end,
})

MainTab:CreateSection("Play Best Move")
MainTab:CreateToggle({
	Name = "Auto Play Best Moves",
	CurrentValue = false,
	Callback = function(Value)
		getgenv().Settings.AutoPlay = Value
		if Value then
			AutoPlay()
		else
			DisconnectAll(getgenv().Info.Connections)
		end
	end,
})

MainTab:CreateButton({
	Name = "Play Best Move",
	Callback = PlayWithFallback,
})
